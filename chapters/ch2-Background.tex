\ifx\wholebook\relax\else

% --------------------------------------------
% Lulu:

    \documentclass[a4paper,12pt,twoside]{../includes/ThesisStyle}

	\input{../includes/macros}
	\input{../includes/formatAndDefs}

	\graphicspath{{.}{../figures/}}
	\begin{document}
\fi

\chapter{Background}
\label{chap:background}
\minitoc

blabla people wants more performance from our baseline jit, sometimes they know or they don't really know.
Also being able to do things at runtime.

We discuss first existing VMs then discuss our state and our differences / details. 

\section{High-performance virtual machines}

\subsection{Mainstream C++ virtual machines}
-- Existing C++ runtimes and why C++ blabla Lars good at maintaining...
talk about java and Javascript (maybe ClR ?) Discuss Azul.
==> TALK about Dart.
==> Tiered architecture

\subsection{The new era: Multi-languages VMs}

one important focus now is to hvae cross language VM to avoid cost of dev...

the interesting approach is that it's more or less meta-circular.

main attempts are pypy and truffle.

generic approach with interpreters.

\subsubsection{Truffle-Graal}

describe the runtime model

explain JIT generation from annotation on AST interpreter

\subsubsection{Pypy}

explain qucikly metatracing from interpreter

present them here so they can be compared to later.

\subsection{Smalltalk virtual machines}

we're st, main competition, so we need to discuss it.

no VM with optimising JIT.

Except strongtalk but never to production
-- matter as it is compared in persistance of optimizations with database of inlining decisions

\section{Existing Pharo runtime}

small intro, repeat what is pharo. we discuss only what matters for the phd, either so that the reader has the correct context or because it may be different from the other VMS leading to different design choices. not everything.

\subsection{Snapshots}

COPIED FROM PAPER. TO change

To avoid this warm-up time, this paper intro- duces an architecture to save a platform-independent ver- sion of the optimized code as part of a snapshot. Snapshots are available in multiple object-oriented languages such as Smalltalk (Goldberg (and) Robson 1983) and later Dart (Anna- malai 2013). Snapshots allow the program to save the heap in a given state, and the virtual machine can resume exe- cution from this snapshot later. Usually, compiled code is available in different versions. On the one hand, a bytecoded version, which is on the heap if the bytecoded version of functions is reified as an object (as in Dart and Smalltalk). On the other hand one or several machine code versions are available in the machine code zone. Machine code versions are usually not part of the heap directly but of a separated part of memory which is marked as executable. Snapshots cannot save easily machine code versions of functions as a snapshot needs to be platform-independent and machine code versions of functions are not regular objects.

SUMMARY:

explain what they are and that they are used in normal development workflow. We look into non workflow breaking solution even if arguably it's bad to use the system that way.

\subsection{Executable code and bytecode representation}

explain stack-based bytecode.
explain compilation to if and loop
+ representation of compiled methods 

\subsection{Virtual machine executable generation}
-- maybe the architecture with Slang and the simulator
It's important to understand the compilation versus runtime model.
Maybe take the example of the interpreter with duplication push temp ? Compiler can't guess, you need annotation or C extensions. Support originally for not so clever compiler.

Doc: not much really. My simulator blog post ?
Or the simulator is just a paragraph, it has no real impact on the thesis.

\subsection{Stack frame reification}
- context to stack mapping + explanations
This is important as used to introspect and edit the stack from the language. Normal uses (exceptions, continuations, debugger) but also now the runtime compiler
Doc: eliot post and my lecture (quit some to do)

\subsection{Baseline JIT}
- baseline JIT behavior + reg alloc + templates + abstractions over back-ends, literal management, Cogits, memory managers
Doc: my blog posts. need to explain template and co

\subsection{Existing Memory Manager}
- the crap in V3 mem manager. Why it needed to change.
take the example of inline cache and class tags and memory representation.
Doc: my blog post. need to explain

\ifx\wholebook\relax\else
    \end{document}
\fi