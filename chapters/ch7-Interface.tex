\ifx\wholebook\relax\else

% --------------------------------------------
% Lulu:

    \documentclass[a4paper,12pt,twoside]{../includes/ThesisStyle}

	\input{../includes/macros}
	\input{../includes/formatAndDefs}

	\graphicspath{{.}{../figures/}}
	\begin{document}
\fi

\chapter{Minimal language-virtual machine interfacee}
\label{chap:interface}
\minitoc


Explain why the interface has to be minimal

type of operations we added. that limit.

machine interface versus bytecode interface, truffle comparison.

Discussion on performance limitation. For example integer overflow or not, at: with all checks.


\section{Runtime information access}

new primitive operation

To extract information from the machine code version of a method, we added a new primitive operation \emph{sendAndBranchData}. This operation can be performed only on compiled methods. If the method has currently a machine code version, the primitive answers the types met at each inline cache and the values of the counters at each branch. This information can be then used by the runtime optimizer to type variables and to detect the usage of each basic block. The primitive answers the runtime information relative to the compiled method and all the closures defined in the compiled method.

\section{New call-backs}

As in our implementation the runtime optimizer and deoptimizer are implemented in Smalltalk run and not in the virtual machine itself, we needed to introduce callbacks activated by the virtual machine to activate the optimizer and the deoptimizer. 

These callbacks use the reification of stack frame available for the debugger to inform the language which frame had its method detected as a hot spot and which frame has to be deoptimized.

\section{Bytecode set extension}

(our work not blind)
To support unsafe operations, the bytecode set needed to be extended. In our previous work, we describe the extended bytecode set used \cite{Bera14a}. The extended bytecode set design relies on the assumption that only a small number of new bytecode instructions are needed for the baseline JIT to produce efficient machine code. Three main kind of instructions were added into the bytecode set:
\begin{itemize}
\item \textbf{Guards}: guards are used to ensure a specific object has a given type, else they trigger dynamic deoptimization.
\item \textbf{Object unchecked accesses}: normally variable-sized objects such as arrays or byte arrays require type and bounds checks to allow a program to access their fields. Unchecked access directly reads the field of an object without any checks.
\item \textbf{Unchecked arithmetics}: Arithmetic operations needs to check for the operand types to know what arithmetic operation to call (on integers, double, etc.). Unchecked operations are typed and do not need these check. In addition, unchecked operations do not do an overflow check and are converted efficiently to machine code conditional branches if followed by a conditional jump.
\end{itemize}

We are considering adding other unchecked operations in the future, for example those related to object creation or stores without the garbage collector write barrier.

The extended bytecode set was designed to use a baseline JIT as a back-end and not an interpreter. It is important to note as we considered that as there are a few optimized methods, we can encode unchecked operations in multiple bytecodes to save other bytecodes for more frequent instructions and lower the overall memory footprint of the runtime. In the case of a bytecode set targetting the bytecode interpreter, we would need to encode unchecked instruction in the smallest number of byte possible as these intructions are on performance critical code and bytecode fetching has a noticeable impact on a bytecode interpreter performance.

%Currently, the extended bytecode set is generated by the runtime optimizing compiler only. If someone adds simple syntaxic extensions to Smalltalk, it is possible to extend slightly the regular bytecode compiler to use unchecked instructions. We did not go in that direction as the unchecked instructions are unsafe, leading potentially in virtual machine crashes if they are used incorrectly, which doesn't work with the protection expected by high-level language programmers. \md{i would move this to the discussion}

Need bytecode set paper in addition + description of new instructions. The precise list come in implementation section.


\ifx\wholebook\relax\else
    \end{document}
\fi