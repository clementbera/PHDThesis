\documentclass[a4paper,12pt,twoside]{includes/ThesisStyle}

\input{includes/macros}
\include{includes/formatAndDefs}
\sloppy

\graphicspath{{.}{figures/}}
\newcommand \logoInria{./includes/logos/Inria}
\newcommand \logoRegion{./includes/logos/Region}
\newcommand \logoLifl{./includes/logos/lifl}
\newcommand \logoUSTL{./includes/logos/Lille1}

\let\wholebook=\relax

\begin{document}
\include{chapters/titlePage}
\dominitoc

\pagenumbering{roman}

\cleardoublepage

\section*{Acknowledgments}

I would like to thank my thesis supervisors St\'ephane Ducasse and Marcus Denker for allowing me to do a Ph.D at the RMoD group, as well as helping and supporting me during the three years of my Ph.D.

I thank the thesis reviewers and jury members Ga\"el Thomas, Laurence Tratt for kindly reviewing my thesis and providing me valuable feedback. I thank Laurence Duchien for leading the jury.

I would like to express my gratitude to Eliot Miranda for his first design of the Sista architecture and his support during the three years of my Ph.D. 

I would like to thank Tim Felgentreff for his evaluation of Sista architecture using the Squeak speed center.

For remarks on earlier versions of this thesis, I thank, in addition to my supervisors, Guillermo Polito, Kavesseri Krishnan Subramaniam and Damien Cassou.

\cleardoublepage

\section*{Abstract}

Most high-level programming languages run on top of a virtual machine (VM) to abstract away from the underlying hardware. To reach high-performance, the VM typically relies on an optimising just-in-time compiler (JIT), which speculates on the program behavior based on its first runs to generate at runtime efficient machine code and speed-up the program execution. As multiple runs are required to speculate correctly on the program behavior, such a VM requires a certain amount of time at start-up to reach peak performance. The optimising JIT itself is usually compiled ahead-of-time to executable code as part of the VM.

The dissertation proposes Sista, an architecture for an optimising JIT, in which the optimised state of the VM can be persisted across multiple VM start-ups and the optimising JIT is running in the same runtime than the program executed. To do so, the optimising JIT is split in two parts. One part is high-level: it performs optimisations specific to the programming language run by the VM and is written in a metacircular style. Staying away from low-level details, this part can be read, edited and debugged while the program is running using the standard tool set of the programming language executed by the VM. The second part is low-level: it performs machine specific optimisations and is compiled ahead-of-time to executable code as part of the VM. The two parts of the JIT use a well-defined intermediate representation to share the code to optimise. This representation is machine-independent and can be persisted across multiple VM start-ups, allowing the VM to reach peak performance very quickly.

To validate the architecture, the dissertation includes the description of an implementation on top of Pharo Smalltalk and its VM. The implementation is able to run a large set of benchmarks, from large application benchmarks provided by industrial users to micro-benchmarks used to measure the performance of specific code patterns. The optimising JIT is implemented according to the architecture proposed and shows significant speed-up (1.5x to 5x) over the current production VM. In addition, large benchmarks show that peak performance can be reached almost immediately after VM start-up if the VM can reuse the optimised state persisted from another run.

\cleardoublepage

\section*{R\'esum\'e}

La plupart des langages de programmation de haut niveau s'exécutent sur une machine virtuelle (VM) pour être indépendant du hardware utilisé. Pour atteindre de hautes performances, la VM repose généralement sur un compilateur à la volée (JIT), qui spécule sur le comportement du programme basé sur ses premières exécutions pour générer à la volée du code machine efficace et accélérer l'exécution du programme. Étant donné que plusieurs exécutions sont nécessaires pour spéculer correctement sur le comportement du programme, une telle VM nécessite un certain temps au démarrage pour atteindre les performances maximales. Le JIT est habituellement compilé en code exécutable avec le reste de la VM avant sa première utilisation.

La thèse propose Sista, une architecture pour un JIT, dans laquelle l'état optimisé de la VM peut être persisté entre plusieurs démarrages de la VM et le JIT s'exécute dans le même environnement d'exécution que le programme exécuté. Pour ce faire, le JIT est divisé en deux parties. Une partie est de haut niveau: elle effectue des optimisations spécifiques au langage de programmation exécuté par la VM et est méta-circulaire. Sans connaissances des détails de bas niveau, cette partie peut être lue, éditée et déboguée pendant le fonctionnement du programme en utilisant les outils de développement du langage de programmation exécuté par la VM. La deuxième partie est de bas niveau: elle effectue des optimisations spécifiques au hardware utilisé et est compilée en code exécutable, au sein de la VM, avant sa première utilisation. Les deux parties du JIT utilisent une représentation intermédiaire bien définie pour échanger le code à optimiser. Cette représentation est indépendante du hardware utilisé et peut être persistée entre plusieurs démarrages de la VM, ce qui permet à la VM d'atteindre rapidement les performances maximales.

Pour valider l'architecture, la thèse inclus la description d'une implémentation utilisant Pharo Smalltalk et sa VM. L'implémentation est évaluée par rapport à différents indices de performance, incluant l'exécution de programme utilisés en entreprise et de petits programmes utilisés pour mesurer la performance d'aspects spécifiques de la VM. Le JIT est implémenté selon l'architecture proposée et permet d'exécuter le programme entre 1,5x et 5x plus vite que la VM en production aujourd'hui. En outre, les indices de performance montrent que les performances maximales peuvent être atteintes presque immédiatement après le démarrage de la VM si cette dernière peut réutiliser l'état optimisé d'une autre exécution.

\tableofcontents
\listoffigures
%\listoftables

\mainmatter

\include{chapters/ch1-Introduction}
\include{chapters/ch2-ExistingVMs}
\include{chapters/ch3-ExistingRuntime}
\include{chapters/ch4-Architecture}
\include{chapters/ch5-RuntimeEvolution}
\include{chapters/ch6-Metacircular}
\include{chapters/ch7-Persistance}
%\include{chapters/ch8-Interface}
\include{chapters/ch9-Validation}
\include{chapters/ch10-FutureWork}
\include{chapters/ch10-Conclusion}

\appendix
\include{appendix/def}

\bibliographystyle{includes/ThesisStyle}
\bibliography{bib/sista}
%bib/rmod, bib/others


\end{document}

%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: "main"
%%% TeX-PDF-mode: t
%%% End:
